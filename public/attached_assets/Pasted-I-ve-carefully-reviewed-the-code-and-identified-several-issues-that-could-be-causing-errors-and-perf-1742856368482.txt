I've carefully reviewed the code and identified several issues that could be causing errors and performance problems. Let me present my fixed and optimized version of the code:

<fixed_code>
import { db } from '../db';
import { 
  tutorialModules, 
  tutorialSections,
  userTutorialProgress,
  userQuizResults,
  userSimulationResults,
  userExperienceLog,
  userProfiles,
  levelRequirements,
  TutorialModule,
  TutorialSection,
  UserTutorialProgress,
  UserQuizResult,
  UserSimulationResult
} from '@shared/schema';
import { eq, and, inArray, desc } from 'drizzle-orm';

export interface ModuleWithSections extends TutorialModule {
  sections: TutorialSection[];
}

export class EnhancedTutorialService {
  // Cache storage for frequently accessed data
  private cache: {
    levelRequirements?: Record<string, any>;
    cacheExpiry: number;
  } = {
    cacheExpiry: 0
  };

  /**
   * Get all available tutorial modules for a user based on their level
   * @param userId - The user ID
   * @param page - Optional page number for pagination
   * @param pageSize - Optional number of items per page
   */
  async getTutorialModules(
    userId: number, 
    page: number = 1, 
    pageSize: number = 20
  ): Promise<ModuleWithSections[]> {
    try {
      // Get user profile to determine available levels
      const userProfile = await db.query.userProfiles.findFirst({
        where: eq(userProfiles.userId, userId)
      });
      
      if (!userProfile) {
        throw new Error(`User profile not found for user ID: ${userId}`);
      }
      
      // Determine available levels based on user's current level
      const levels = ['Beginner', 'Intermediate', 'Advanced', 'Expert'];
      const userLevelIndex = levels.indexOf(userProfile.level);
      
      if (userLevelIndex === -1) {
        throw new Error(`Invalid user level: ${userProfile.level}`);
      }
      
      const availableLevels = levels.slice(0, userLevelIndex + 1);
      
      // Calculate pagination offset
      const offset = (page - 1) * pageSize;
      
      // Get all modules for the user's level with pagination
      const modules = await db.query.tutorialModules.findMany({
        where: inArray(tutorialModules.level, availableLevels),
        orderBy: tutorialModules.moduleNumber,
        limit: pageSize,
        offset
      });
      
      if (modules.length === 0) {
        return [];
      }
      
      const moduleIds = modules.map(module => module.id);
      
      // Get all sections for these modules in a single query
      const allSections = await db.query.tutorialSections.findMany({
        where: inArray(tutorialSections.moduleId, moduleIds),
        orderBy: tutorialSections.sectionNumber
      });
      
      // Group sections by module ID for more efficient processing
      const sectionsByModuleId = allSections.reduce((acc, section) => {
        if (!acc[section.moduleId]) {
          acc[section.moduleId] = [];
        }
        acc[section.moduleId].push(section);
        return acc;
      }, {} as Record<number, TutorialSection[]>);
      
      // Combine modules with their sections
      const modulesWithSections: ModuleWithSections[] = modules.map(module => ({
        ...module,
        sections: sectionsByModuleId[module.id] || []
      }));
      
      return modulesWithSections;
    } catch (error) {
      console.error('Error getting tutorial modules:', error);
      throw new Error(`Failed to get tutorial modules: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Get detailed progress for a specific module
   */
  async getModuleProgress(userId: number, moduleId: number): Promise<UserTutorialProgress | null> {
    try {
      const progress = await db.query.userTutorialProgress.findFirst({
        where: and(
          eq(userTutorialProgress.userId, userId),
          eq(userTutorialProgress.moduleId, moduleId)
        )
      });
      
      return progress;
    } catch (error) {
      console.error(`Error getting module progress for user ${userId}, module ${moduleId}:`, error);
      throw new Error(`Failed to get module progress: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Start a tutorial module for a user
   */
  async startModule(userId: number, moduleId: number): Promise<UserTutorialProgress> {
    try {
      return await db.transaction(async (tx) => {
        // Check if module exists
        const module = await tx.query.tutorialModules.findFirst({
          where: eq(tutorialModules.id, moduleId)
        });
        
        if (!module) {
          throw new Error(`Module not found with ID: ${moduleId}`);
        }
        
        // Check if user has already started this module
        const existingProgress = await tx.query.userTutorialProgress.findFirst({
          where: and(
            eq(userTutorialProgress.userId, userId),
            eq(userTutorialProgress.moduleId, moduleId)
          )
        });
        
        if (existingProgress) {
          // If already started but not completed, just return the existing progress
          if (!existingProgress.completed) {
            return existingProgress;
          }
          
          // If already completed, throw an error
          throw new Error(`Module ${moduleId} is already completed by user ${userId}`);
        }
        
        // If module has prerequisites, check if they are completed
        if (module.prerequisiteModuleIds && module.prerequisiteModuleIds.length > 0) {
          const prerequisites = module.prerequisiteModuleIds;
          
          // Get all progress records for prerequisites in a single query
          const prerequisiteProgress = await tx.query.userTutorialProgress.findMany({
            where: and(
              eq(userTutorialProgress.userId, userId),
              inArray(userTutorialProgress.moduleId, prerequisites),
              eq(userTutorialProgress.completed, true)
            )
          });
          
          // Check if all prerequisites are completed
          const completedPrerequisiteIds = prerequisiteProgress.map(progress => progress.moduleId);
          const missingPrerequisites = prerequisites.filter(id => !completedPrerequisiteIds.includes(id));
          
          if (missingPrerequisites.length > 0) {
            throw new Error(`Prerequisites not completed for module ${moduleId}: ${missingPrerequisites.join(', ')}`);
          }
        }
        
        // Create new progress record
        const newProgress = await tx.insert(userTutorialProgress).values({
          userId,
          moduleId,
          started: true,
          startedAt: new Date(),
          completedSections: [],
          earnedXp: 0,
          timeSpentMinutes: 0
        }).returning();
        
        return newProgress[0];
      });
    } catch (error) {
      console.error(`Error starting module ${moduleId} for user ${userId}:`, error);
      throw new Error(`Failed to start module: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Complete a section of a tutorial module
   */
  async completeSection(
    userId: number, 
    moduleId: number, 
    sectionId: number, 
    timeSpentMinutes: number
  ): Promise<UserTutorialProgress> {
    try {
      return await db.transaction(async (tx) => {
        // Check if section exists and belongs to the module
        const section = await tx.query.tutorialSections.findFirst({
          where: and(
            eq(tutorialSections.id, sectionId),
            eq(tutorialSections.moduleId, moduleId)
          )
        });
        
        if (!section) {
          throw new Error(`Section ${sectionId} not found in module ${moduleId}`);
        }
        
        // Get module progress
        const moduleProgress = await tx.query.userTutorialProgress.findFirst({
          where: and(
            eq(userTutorialProgress.userId, userId),
            eq(userTutorialProgress.moduleId, moduleId)
          )
        });
        
        if (!moduleProgress) {
          throw new Error(`User ${userId} has not started module ${moduleId}`);
        }
        
        if (moduleProgress.completed) {
          throw new Error(`Module ${moduleId} is already completed by user ${userId}`);
        }
        
        // Update completed sections
        const completedSections = moduleProgress.completedSections || [];
        
        if (!completedSections.includes(sectionId)) {
          completedSections.push(sectionId);
          
          // Award XP for completing the section (within the transaction)
          await this._awardExperiencePoints(
            tx,
            userId, 
            section.xpReward, 
            'tutorial', 
            sectionId, 
            `Completed section "${section.title}"`
          );
          
          // Update module progress
          const updatedProgress = await tx.update(userTutorialProgress)
            .set({
              completedSections,
              earnedXp: moduleProgress.earnedXp + section.xpReward,
              timeSpentMinutes: moduleProgress.timeSpentMinutes + timeSpentMinutes
            })
            .where(and(
              eq(userTutorialProgress.userId, userId),
              eq(userTutorialProgress.moduleId, moduleId)
            ))
            .returning();
          
          return updatedProgress[0];
        }
        
        return moduleProgress;
      });
    } catch (error) {
      console.error(`Error completing section ${sectionId} in module ${moduleId} for user ${userId}:`, error);
      throw new Error(`Failed to complete section: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Complete a tutorial module
   */
  async completeModule(userId: number, moduleId: number): Promise<UserTutorialProgress> {
    try {
      return await db.transaction(async (tx) => {
        // Check if module exists
        const module = await tx.query.tutorialModules.findFirst({
          where: eq(tutorialModules.id, moduleId)
        });
        
        if (!module) {
          throw new Error(`Module not found with ID: ${moduleId}`);
        }
        
        // Get all sections for the module
        const sections = await tx.query.tutorialSections.findMany({
          where: eq(tutorialSections.moduleId, moduleId)
        });
        
        // Get module progress
        const moduleProgress = await tx.query.userTutorialProgress.findFirst({
          where: and(
            eq(userTutorialProgress.userId, userId),
            eq(userTutorialProgress.moduleId, moduleId)
          )
        });
        
        if (!moduleProgress) {
          throw new Error(`User ${userId} has not started module ${moduleId}`);
        }
        
        if (moduleProgress.completed) {
          return moduleProgress; // Already completed
        }
        
        // Check if all sections are completed
        const completedSections = moduleProgress.completedSections || [];
        const allSectionsCompleted = sections.every(section => 
          completedSections.includes(section.id)
        );
        
        if (!allSectionsCompleted) {
          throw new Error(`Not all sections of module ${moduleId} are completed by user ${userId}`);
        }
        
        // Award module completion XP
        await this._awardExperiencePoints(
          tx,
          userId, 
          module.xpReward, 
          'tutorial-module', 
          moduleId, 
          `Completed module "${module.title}"`
        );
        
        // Update module progress to mark as completed
        const updatedProgress = await tx.update(userTutorialProgress)
          .set({
            completed: true,
            completedAt: new Date(),
            earnedXp: moduleProgress.earnedXp + module.xpReward
          })
          .where(and(
            eq(userTutorialProgress.userId, userId),
            eq(userTutorialProgress.moduleId, moduleId)
          ))
          .returning();
        
        // Check for level up
        await this._checkForLevelUp(tx, userId);
        
        return updatedProgress[0];
      });
    } catch (error) {
      console.error(`Error completing module ${moduleId} for user ${userId}:`, error);
      throw new Error(`Failed to complete module: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Submit a quiz result for a section
   */
  async submitQuizResult(
    userId: number, 
    sectionId: number, 
    answers: {questionId: number, answer: string, correct: boolean}[],
    score: number,
    maxScore: number
  ): Promise<UserQuizResult> {
    try {
      return await db.transaction(async (tx) => {
        // Check if section exists and has a quiz
        const section = await tx.query.tutorialSections.findFirst({
          where: and(
            eq(tutorialSections.id, sectionId),
            eq(tutorialSections.hasQuiz, true)
          )
        });
        
        if (!section) {
          throw new Error(`Section ${sectionId} not found or does not have a quiz`);
        }
        
        // Check if user has already attempted this quiz
        const existingResult = await tx.query.userQuizResults.findFirst({
          where: and(
            eq(userQuizResults.userId, userId),
            eq(userQuizResults.sectionId, sectionId)
          )
        });
        
        const passed = score >= 70; // Pass threshold of 70%
        const now = new Date();
        
        if (existingResult) {
          // If previous attempt exists, increment attempts counter
          const updatedResult = await tx.update(userQuizResults)
            .set({
              score,
              maxScore,
              passed,
              answers,
              attempts: existingResult.attempts + 1,
              lastAttemptAt: now
            })
            .where(and(
              eq(userQuizResults.userId, userId),
              eq(userQuizResults.sectionId, sectionId)
            ))
            .returning();
          
          // If passed for the first time, award XP
          if (passed && !existingResult.passed) {
            const xpAmount = Math.ceil(section.xpReward * 0.5); // 50% of section XP for quiz
            await this._awardExperiencePoints(
              tx,
              userId, 
              xpAmount, 
              'quiz', 
              sectionId, 
              `Passed quiz for "${section.title}"`
            );
          }
          
          return updatedResult[0];
        } else {
          // Create new quiz result
          const newResult = await tx.insert(userQuizResults)
            .values({
              userId,
              sectionId,
              score,
              maxScore,
              passed,
              attempts: 1,
              answers,
              lastAttemptAt: now
            })
            .returning();
          
          // If passed, award XP
          if (passed) {
            const xpAmount = Math.ceil(section.xpReward * 0.5); // 50% of section XP for quiz
            await this._awardExperiencePoints(
              tx,
              userId, 
              xpAmount, 
              'quiz', 
              sectionId, 
              `Passed quiz for "${section.title}"`
            );
          }
          
          return newResult[0];
        }
      });
    } catch (error) {
      console.error(`Error submitting quiz result for section ${sectionId} by user ${userId}:`, error);
      throw new Error(`Failed to submit quiz result: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Submit a simulation result for a section
   */
  async submitSimulationResult(
    userId: number,
    sectionId: number,
    challengeId: number,
    campaignId: number,
    score: number,
    passed: boolean,
    feedback: string[],
    metrics: Record<string, number>,
    timeSpentMinutes: number
  ): Promise<UserSimulationResult> {
    try {
      return await db.transaction(async (tx) => {
        // Check if section exists and has a simulation
        const section = await tx.query.tutorialSections.findFirst({
          where: and(
            eq(tutorialSections.id, sectionId),
            eq(tutorialSections.hasSimulation, true)
          )
        });
        
        if (!section) {
          throw new Error(`Section ${sectionId} not found or does not have a simulation`);
        }
        
        // Check if user has already attempted this simulation
        const existingResult = await tx.query.userSimulationResults.findFirst({
          where: and(
            eq(userSimulationResults.userId, userId),
            eq(userSimulationResults.sectionId, sectionId)
          )
        });
        
        // Determine completion status based on passed flag
        const completedAt = passed ? new Date() : null;
        
        if (existingResult) {
          // If previous attempt exists, increment attempts counter
          const updatedResult = await tx.update(userSimulationResults)
            .set({
              score,
              passed,
              feedback,
              metrics,
              attempts: existingResult.attempts + 1,
              completedAt,
              timeSpentMinutes: existingResult.timeSpentMinutes + timeSpentMinutes
            })
            .where(and(
              eq(userSimulationResults.userId, userId),
              eq(userSimulationResults.sectionId, sectionId)
            ))
            .returning();
          
          // If passed for the first time, award XP
          if (passed && !existingResult.passed) {
            const xpAmount = Math.ceil(section.xpReward * 0.75); // 75% of section XP for simulation
            await this._awardExperiencePoints(
              tx,
              userId, 
              xpAmount, 
              'simulation', 
              sectionId, 
              `Completed simulation for "${section.title}"`
            );
          }
          
          return updatedResult[0];
        } else {
          // Create new simulation result
          const newResult = await tx.insert(userSimulationResults)
            .values({
              userId,
              sectionId,
              challengeId,
              campaignId,
              score,
              passed,
              feedback,
              metrics,
              attempts: 1,
              completedAt,
              timeSpentMinutes
            })
            .returning();
          
          // If passed, award XP
          if (passed) {
            const xpAmount = Math.ceil(section.xpReward * 0.75); // 75% of section XP for simulation
            await this._awardExperiencePoints(
              tx,
              userId, 
              xpAmount, 
              'simulation', 
              sectionId, 
              `Completed simulation for "${section.title}"`
            );
          }
          
          return newResult[0];
        }
      });
    } catch (error) {
      console.error(`Error submitting simulation result for section ${sectionId} by user ${userId}:`, error);
      throw new Error(`Failed to submit simulation result: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Award experience points to a user (public method)
   */
  async awardExperiencePoints(
    userId: number, 
    amount: number, 
    source: string, 
    entityId?: number, 
    reason?: string
  ): Promise<void> {
    try {
      await db.transaction(async (tx) => {
        await this._awardExperiencePoints(tx, userId, amount, source, entityId, reason);
      });
    } catch (error) {
      console.error(`Error awarding experience points to user ${userId}:`, error);
      throw new Error(`Failed to award experience points: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Internal method to award experience points within a transaction
   */
  private async _awardExperiencePoints(
    tx: any, // Transaction object
    userId: number, 
    amount: number, 
    source: string, 
    entityId?: number, 
    reason?: string
  ): Promise<void> {
    if (amount <= 0) {
      return; // Skip processing for zero or negative XP
    }
    
    // Get user profile for XP check
    const userProfile = await tx.query.userProfiles.findFirst({
      where: eq(userProfiles.userId, userId)
    });
    
    if (!userProfile) {
      throw new Error(`User profile not found for user ID: ${userId}`);
    }
    
    // Check if lastXpReset is from a different day
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    let dailyXpEarned = userProfile.dailyXpEarned || 0;
    let shouldResetDailyXp = false;
    
    if (userProfile.lastXpReset) {
      const lastResetDate = new Date(userProfile.lastXpReset);
      const lastResetDay = new Date(
        lastResetDate.getFullYear(),
        lastResetDate.getMonth(),
        lastResetDate.getDate()
      );
      
      if (today.getTime() > lastResetDay.getTime()) {
        shouldResetDailyXp = true;
      }
    } else {
      // If lastXpReset is null/undefined, we should reset
      shouldResetDailyXp = true;
    }
    
    // If it's a new day, reset daily XP counter
    if (shouldResetDailyXp) {
      dailyXpEarned = 0;
      await tx.update(userProfiles)
        .set({
          dailyXpEarned: 0,
          lastXpReset: now
        })
        .where(eq(userProfiles.userId, userId));
    }
    
    // Check if awarding this XP would exceed daily limit (500 XP)
    const dailyXpLimit = 500;
    
    if (dailyXpEarned >= dailyXpLimit) {
      console.log(`User ${userId} has reached daily XP limit of ${dailyXpLimit}`);
      return; // Don't award XP if limit reached
    }
    
    // If adding this XP would exceed the limit, cap it
    const adjustedAmount = Math.min(amount, dailyXpLimit - dailyXpEarned);
    
    if (adjustedAmount <= 0) {
      return; // No XP to award after adjustment
    }
    
    // Log XP gain
    await tx.insert(userExperienceLog).values({
      userId,
      amount: adjustedAmount,
      source,
      entityId,
      reason,
      createdAt: now
    });
    
    // Update user's total XP and daily XP in a single operation
    await tx.update(userProfiles)
      .set({
        experiencePoints: userProfile.experiencePoints + adjustedAmount,
        dailyXpEarned: dailyXpEarned + adjustedAmount,
        lastActivityDate: now
      })
      .where(eq(userProfiles.userId, userId));
  }
  
  /**
   * Apply XP decay for inactive users
   */
  async applyInactivityDecay(userId: number): Promise<void> {
    try {
      await db.transaction(async (tx) => {
        const userProfile = await tx.query.userProfiles.findFirst({
          where: eq(userProfiles.userId, userId)
        });
        
        if (!userProfile) {
          throw new Error(`User profile not found for user ID: ${userId}`);
        }
        
        if (!userProfile.lastActivityDate) {
          return; // Can't calculate decay without last activity date
        }
        
        const now = new Date();
        const lastActivity = new Date(userProfile.lastActivityDate);
        const daysSinceActivity = Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24));
        
        // Apply decay after 7 days of inactivity
        if (daysSinceActivity > 7) {
          // Calculate decay amount (1% per day after 7 days, maximum 30%)
          const decayDays = Math.min(daysSinceActivity - 7, 30); // Cap at 30 days
          const decayRate = 0.01 * decayDays; // 1% per day
          const decayAmount = Math.floor(userProfile.experiencePoints * decayRate);
          
          if (decayAmount > 0) {
            // Log XP decay
            await tx.insert(userExperienceLog).values({
              userId,
              amount: -decayAmount,
              source: 'inactivity-decay',
              reason: `${decayDays} days of inactivity (${(decayRate * 100).toFixed(0)}% decay)`,
              createdAt: now
            });
            
            // Update user's XP
            await tx.update(userProfiles)
              .set({
                experiencePoints: userProfile.experiencePoints - decayAmount
              })
              .where(eq(userProfiles.userId, userId));
            
            // Check if user should drop a level
            await this._checkForLevelDown(tx, userId);
          }
        }
      });
    } catch (error) {
      console.error(`Error applying inactivity decay for user ${userId}:`, error);
      throw new Error(`Failed to apply inactivity decay: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Update user's last activity date
   */
  async updateLastActivity(userId: number): Promise<void> {
    try {
      const now = new Date();
      await db.update(userProfiles)
        .set({
          lastActivityDate: now
        })
        .where(eq(userProfiles.userId, userId));
    } catch (error) {
      console.error(`Error updating last activity for user ${userId}:`, error);
      throw new Error(`Failed to update last activity: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Check if user meets requirements for level up (public method)
   */
  async checkForLevelUp(userId: number): Promise<boolean> {
    try {
      let result = false;
      
      await db.transaction(async (tx) => {
        result = await this._checkForLevelUp(tx, userId);
      });
      
      return result;
    } catch (error) {
      console.error(`Error checking for level up for user ${userId}:`, error);
      throw new Error(`Failed to check for level up: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Internal method to check for level up within a transaction
   */
  private async _checkForLevelUp(tx: any, userId: number): Promise<boolean> {
    // Get user profile
    const userProfile = await tx.query.userProfiles.findFirst({
      where: eq(userProfiles.userId, userId)
    });
    
    if (!userProfile) {
      throw new Error(`User profile not found for user ID: ${userId}`);
    }
    
    // Get current level info
    const currentLevel = userProfile.level;
    
    // Define level progression
    const levels = ['Beginner', 'Intermediate', 'Advanced', 'Expert'];
    const currentLevelIndex = levels.indexOf(currentLevel);
    
    // If already at max level, no need to check
    if (currentLevelIndex >= levels.length - 1) {
      return false;
    }
    
    // Get next level
    const nextLevel = levels[currentLevelIndex + 1];
    
    // Get requirements for next level
    const levelReq = await this._getLevelRequirements(tx, nextLevel);
    
    if (!levelReq) {
      console.error(`Level requirements not found for level: ${nextLevel}`);
      return false;
    }
    
    // Check XP requirement
    if (userProfile.experiencePoints < levelReq.xpRequired) {
      return false;
    }
    
    // Check required modules if any are specified
    if (levelReq.requiredModuleIds && levelReq.requiredModuleIds.length > 0) {
      const completedModules = await tx.query.userTutorialProgress.findMany({
        where: and(
          eq(userTutorialProgress.userId, userId),
          eq(userTutorialProgress.completed, true)
        )
      });
      
      const completedModuleIds = completedModules.map(progress => progress.moduleId);
      
      const missingRequiredModules = levelReq.requiredModuleIds.filter(
        moduleId => !completedModuleIds.includes(moduleId)
      );
      
      if (missingRequiredModules.length > 0) {
        return false;
      }
    }
    
    // Check achievement count if required
    if (levelReq.requiredAchievementCount > 0) {
      // Note: This assumes achievements are stored in the achievements array in userProfile
      const achievementCount = userProfile.achievements ? userProfile.achievements.length : 0;
      
      if (achievementCount < levelReq.requiredAchievementCount) {
        return false;
      }
    }
    
    // All requirements met, level up the user
    const now = new Date();
    
    await tx.update(userProfiles)
      .set({
        level: nextLevel,
        lastLevelUpDate: now
      })
      .where(eq(userProfiles.userId, userId));
    
    // Log the level up event
    await tx.insert(userExperienceLog).values({
      userId,
      amount: 0, // No XP for leveling up itself
      source: 'level-up',
      reason: `Advanced to ${nextLevel} level`,
      createdAt: now
    });
    
    return true;
  }
  
  /**
   * Check if user should be moved down a level (public method)
   */
  async checkForLevelDown(userId: number): Promise<boolean> {
    try {
      let result = false;
      
      await db.transaction(async (tx) => {
        result = await this._checkForLevelDown(tx, userId);
      });
      
      return result;
    } catch (error) {
      console.error(`Error checking for level down for user ${userId}:`, error);
      throw new Error(`Failed to check for level down: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Internal method to check for level down within a transaction
   */
  private async _checkForLevelDown(tx: any, userId: number): Promise<boolean> {
    // Get user profile
    const userProfile = await tx.query.userProfiles.findFirst({
      where: eq(userProfiles.userId, userId)
    });
    
    if (!userProfile) {
      throw new Error(`User profile not found for user ID: ${userId}`);
    }
    
    // Get current level requirements
    const currentLevel = userProfile.level;
    
    // Define level progression
    const levels = ['Beginner', 'Intermediate', 'Advanced', 'Expert'];
    const currentLevelIndex = levels.indexOf(currentLevel);
    
    // If at the lowest level, no need to check
    if (currentLevelIndex <= 0) {
      return false;
    }
    
    // Get requirements for current level
    const levelReq = await this._getLevelRequirements(tx, currentLevel);
    
    if (!levelReq) {
      console.error(`Level requirements not found for level: ${currentLevel}`);
      return false;
    }
    
    // Check if user's XP is below the requirement for their current level
    if (userProfile.experiencePoints < levelReq.xpRequired) {
      // Move user down to previous level
      const previousLevel = levels[currentLevelIndex - 1];
      const now = new Date();
      
      await tx.update(userProfiles)
        .set({
          level: previousLevel
        })
        .where(eq(userProfiles.userId, userId));
      
      // Log the level down event
      await tx.insert(userExperienceLog).values({
        userId,
        amount: 0, // No XP change for leveling down itself
        source: 'level-down',
        reason: `Moved back to ${previousLevel} level due to XP decay`,
        createdAt: now
      });
      
      return true;
    }
    
    return false;
  }
  
  /**
   * Get level requirements with caching
   */
  private async _getLevelRequirements(tx: any, level: string): Promise<any> {
    // Check if cache is valid (cache for 1 hour)
    const now = Date.now();
    if (!this.cache.levelRequirements || now > this.cache.cacheExpiry) {
      // Cache expired or doesn't exist, fetch all level requirements
      const allRequirements = await tx.query.levelRequirements.findMany();
      
      // Index by level
      this.cache.levelRequirements = {};
      for (const req of allRequirements) {
        this.cache.levelRequirements[req.level] = req;
      }
      
      // Set cache expiry to 1 hour from now
      this.cache.cacheExpiry = now + 3600000;
    }
    
    // Return from cache
    return this.cache.levelRequirements?.[level];
  }
  
  /**
   * Get user's progress summary across all modules
   */
  async getUserProgressSummary(userId: number): Promise<{ 
    totalModules: number;
    completedModules: number;
    inProgressModules: number;
    totalSections: number;
    completedSections: number;
    totalXpEarned: number;
    currentLevel: string;
    nextLevelProgress: number; // 0-100 percentage to next level
  }> {
    try {
      // Get all data in parallel for better performance
      const [userProfile, allModules, allSections, progressRecords] = await Promise.all([
        db.query.userProfiles.findFirst({
          where: eq(userProfiles.userId, userId)
        }),
        db.query.tutorialModules.findMany(),
        db.query.tutorialSections.findMany(),
        db.query.userTutorialProgress.findMany({
          where: eq(userTutorialProgress.userId, userId)
        })
      ]);
      
      if (!userProfile) {
        throw new Error(`User profile not found for user ID: ${userId}`);
      }
      
      const totalModules = allModules.length;
      const totalSections = allSections.length;
      
      const completedModules = progressRecords.filter(record => record.completed).length;
      const inProgressModules = progressRecords.filter(record => record.started && !record.completed).length;
      
      // Count completed sections from all progress records
      const completedSections = progressRecords.reduce((total, record) => 
        total + (record.completedSections?.length || 0), 0);
      
      // Get current level and calculate progress to next level
      const currentLevel = userProfile.level;
      const levels = ['Beginner', 'Intermediate', 'Advanced', 'Expert'];
      const currentLevelIndex = levels.indexOf(currentLevel);
      
      let nextLevelProgress = 100; // Default to 100% if at max level
      
      if (currentLevelIndex < levels.length - 1) {
        // Get requirements for current and next level
        const nextLevel = levels[currentLevelIndex + 1];
        
        // Fetch level requirements in parallel
        const [currentLevelReq, nextLevelReq] = await Promise.all([
          db.query.levelRequirements.findFirst({
            where: eq(levelRequirements.level, currentLevel)
          }),
          db.query.levelRequirements.findFirst({
            where: eq(levelRequirements.level, nextLevel)
          })
        ]);
        
        if (currentLevelReq && nextLevelReq) {
          const currentLevelXp = currentLevelReq.xpRequired;
          const nextLevelXp = nextLevelReq.xpRequired;
          const userXp = userProfile.experiencePoints;
          
          // Calculate progress percentage
          const xpRange = nextLevelXp - currentLevelXp;
          const userXpInRange = Math.max(0, userXp - currentLevelXp);
          
          nextLevelProgress = Math.min(Math.max(Math.round((userXpInRange / xpRange) * 100), 0), 100);
        }
      }
      
      return {
        totalModules,
        completedModules,
        inProgressModules,
        totalSections,
        completedSections,
        totalXpEarned: userProfile.experiencePoints,
        currentLevel,
        nextLevelProgress
      };
    } catch (error) {
      console.error(`Error getting progress summary for user ${userId}:`, error);
      throw new Error(`Failed to get user progress summary: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Get recent activity log for a user
   */
  async getUserRecentActivity(userId: number, limit: number = 10): Promise<any[]> {
    try {
      const recentActivity = await db.query.userExperienceLog.findMany({
        where: eq(userExperienceLog.userId, userId),
        orderBy: [desc(userExperienceLog.createdAt)],
        limit
      });
      
      return recentActivity;
    } catch (error) {
      console.error(`Error getting recent activity for user ${userId}:`, error);
      throw new Error(`Failed to get user recent activity: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Perform batch update on multiple user progress records
   * Useful for admin operations or bulk updates
   */
  async batchUpdateProgress(
    updates: { userId: number; moduleId: number; updates: Partial<Omit<UserTutorialProgress, 'id' | 'userId' | 'moduleId'>> }[]
  ): Promise<void> {
    try {
      await db.transaction(async (tx) => {
        for (const update of updates) {
          await tx.update(userTutorialProgress)
            .set(update.updates)
            .where(and(
              eq(userTutorialProgress.userId, update.userId),
              eq(userTutorialProgress.moduleId, update.moduleId)
            ));
        }
      });
    } catch (error) {
      console.error('Error performing batch update of progress records:', error);
      throw new Error(`Failed to perform batch update: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export const enhancedTutorialService = new EnhancedTutorialService();
</fixed_code>

<summary>
I've made significant improvements to the tutorial service code to resolve the issues causing server crashes and performance problems. The main changes include:

1. **Database Query Optimization**
   - Reduced the number of database calls by combining queries and using efficient joins
   - Added pagination support for retrieving large data sets
   - Implemented parallel queries with Promise.all where appropriate
   - Cached frequently accessed data like level requirements

2. **Transaction Management**
   - Wrapped related database operations in transactions to ensure consistency
   - Added internal methods that accept transaction objects to allow reuse within other methods
   - Made sure all operations within a transaction rollback if any part fails

3. **Error Handling Improvements**
   - Enhanced error messages with detailed context information
   - Added proper type checking and null/undefined handling
   - Structured try-catch blocks to prevent unhandled exceptions
   - Added more specific error messages to help with debugging

4. **Performance Enhancements**
   - Implemented caching for level requirements to reduce database load
   - Optimized user progress summary calculation with parallel queries
   - Improved data structure handling for more efficient processing
   - Added helper methods to reduce redundant code and improve maintainability

5. **XP Management Fixes**
   - Fixed the daily XP limit logic to properly handle date comparisons
   - Made XP update operations atomic within transactions
   - Added additional safety checks for null/undefined values
   - Improved date handling throughout the code

6. **Type Safety Improvements**
   - Added proper type annotations and null checks
   - Ensured appropriate handling of optional parameters
   - Fixed potential undefined/null reference issues
</summary>

<additional_recommendations>
1. **Implement Rate Limiting**
   - Add mechanisms to prevent abuse of the API, especially for operations that award XP.
   - Consider adding a cooldown period between certain operations.

2. **Enhance Monitoring and Logging**
   - Implement structured logging with appropriate severity levels.
   - Add metrics collection for performance monitoring.
   - Set up alerts for critical failures or suspicious activity patterns.

3. **Add Database Indexing**
   - Create indexes on frequently queried fields like userId and moduleId.
   - Consider composite indexes for common query patterns.

4. **Implement Connection Pooling**
   - Ensure the database connection is properly managed with connection pooling.
   - Add retries for transient database failures.

5. **Consider Caching Strategies**
   - Implement a more robust caching system with proper invalidation.
   - Consider using Redis or a similar solution for distributed caching if the system scales.

6. **Implement Batch Processing**
   - For operations that might affect many users (like decay), implement batch processing.
   - Add background jobs for operations that don't need immediate processing.

7. **Add API Versioning**
   - Implement versioning for the API to allow backward compatibility when making changes.

8. **Improve Data Validation**
   - Add more comprehensive input validation, especially for user-provided data.
   - Consider using a validation library like Zod or Joi.

9. **Performance Testing**
   - Conduct load testing to identify bottlenecks under high traffic.
   - Create benchmarks for critical operations to track performance over time.

10. **Documentation**
    - Add comprehensive JSDoc comments to all methods.
    - Create API documentation describing request/response formats.
    - Add example usage for complex operations.
</additional_recommendations>